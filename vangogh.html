<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Van Gogh: Realistic Cycle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Caveat', cursive;
            user-select: none;
            -webkit-user-select: none;
            /* 全局禁止默认触摸行为 */
            touch-action: none;
        }

        .canvas-container {
            filter: url('#soft-impasto'); 
            width: 100vw;
            height: 100vh;
        }

        .control-panel {
            position: absolute;
            bottom: 40px;
            right: 40px;
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            color: #f1c40f;
            font-size: 2rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s, background 0.2s; /* 优化过渡 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            outline: none;
            
            /* === 关键修复：防止系统接管触摸 === */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; 
        }

        .btn:active, .btn.active-state {
            transform: scale(0.9);
            background: rgba(241, 196, 15, 0.2);
            border-color: #f1c40f;
        }

        .time-indicator {
            color: rgba(255,255,255,0.6);
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            width: 80px;
            text-align: center;
            pointer-events: none;
        }

        .svg-defs { position: absolute; width: 0; height: 0; }
        
        .hint {
            position: absolute;
            bottom: 120px;
            right: 40px;
            color: rgba(255,255,255,0.4);
            text-align: center;
            width: 220px;
            pointer-events: none;
            font-size: 1rem;
        }
        
        @media (max-width: 768px) {
            .control-panel { bottom: 30px; right: 20px; gap: 15px; }
            .btn { width: 65px; height: 65px; font-size: 1.8rem; }
            .hint { bottom: 110px; right: 20px; font-size: 0.9rem; }
        }
    </style>
</head>
<body>

    <svg class="svg-defs">
        <filter id="soft-impasto">
            <feTurbulence type="fractalNoise" baseFrequency="0.005" numOctaves="3" result="noise" />
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="4" />
            <feDiffuseLighting in="noise" lighting-color="#fff" surfaceScale="1.5">
                <feDistantLight azimuth="45" elevation="60" />
            </feDiffuseLighting>
            <feComposite operator="in" in2="SourceGraphic"/>
            <feBlend mode="multiply" in2="SourceGraphic" />
        </filter>
    </svg>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="hint">Hold buttons to control sun/moon</div>

    <div class="control-panel">
        <!-- 禁止右键菜单 -->
        <div class="btn" id="btn-prev" oncontextmenu="return false;">↺</div>
        <div class="time-indicator" id="time-text">NOON</div>
        <div class="btn" id="btn-next" oncontextmenu="return false;">↻</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const timeText = document.getElementById('time-text');

        let width, height;
        let clouds = [];
        let seagulls = [];
        let stars = [];
        let time = 0;
        
        // === 核心状态 ===
        // 保持你原来的逻辑
        let cycleAngle = 270; 
        
        // 旋转方向
        let rotationDirection = 0;
        const rotationSpeed = 0.8; 

        // === 按钮逻辑 (超级稳定版) ===
        // 使用 Pointer Events 代替 Mouse/Touch，彻底解决卡死
        
        function bindButton(id, dir) {
            const btn = document.getElementById(id);
            
            // 按下
            btn.onpointerdown = function(e) {
                e.preventDefault();
                // 锁定指针：这是解决“滑出按钮就失效”的关键
                btn.setPointerCapture(e.pointerId);
                rotationDirection = dir;
                btn.classList.add('active-state');
            };

            // 停止 (松开/取消/离开)
            const stop = function(e) {
                e.preventDefault();
                rotationDirection = 0;
                btn.classList.remove('active-state');
            };

            btn.onpointerup = stop;
            btn.onpointercancel = stop; // 系统打断时触发
        }

        bindButton('btn-next', 1);
        bindButton('btn-prev', -1);

        // === 下面完全保留你原来的数学逻辑和渲染代码 ===

        // === 色彩配置 ===
        const palette = {
            noon: { sky: [100, 180, 230], sea: [0, 105, 148], sun: [255, 255, 240] },
            sunset: { sky: [200, 80, 50], sea: [100, 40, 30], sun: [255, 140, 0] },
            night: { sky: [10, 15, 35], sea: [5, 5, 20], sun: [220, 220, 230] } // sun在这里指代月亮颜色
        };

        // === 实体类定义 ===

        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * (height * 0.55); 
                this.baseSize = Math.random() * 2 + 1;
                this.blinkSpeed = Math.random() * 0.05 + 0.01;
                this.offset = Math.random() * Math.PI * 2;
            }
            draw(opacity) {
                let blink = 0.5 + Math.sin(time * this.blinkSpeed + this.offset) * 0.5; 
                let finalAlpha = opacity * blink;
                if (finalAlpha <= 0.01) return;
                ctx.fillStyle = `rgba(255, 255, 255, ${finalAlpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.baseSize, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * (height * 0.4);
                this.speed = Math.random() * 0.2 + 0.1;
                this.scale = Math.random() * 0.5 + 0.5;
                this.parts = [];
                let partsCount = 3 + Math.floor(Math.random() * 3);
                for(let i=0; i<partsCount; i++) {
                    this.parts.push({
                        x: (Math.random() - 0.5) * 40 * this.scale,
                        y: (Math.random() - 0.5) * 20 * this.scale,
                        r: (20 + Math.random() * 15) * this.scale
                    });
                }
            }
            update() {
                this.x += this.speed;
                if (this.x > width + 100) this.x = -100;
            }
            draw(opacity) {
                if (opacity <= 0.01) return;
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                this.parts.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(this.x + p.x, this.y + p.y, p.r, 0, Math.PI*2);
                    ctx.fill();
                });
            }
        }

        class Seagull {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * (height * 0.5);
                this.speed = Math.random() * 0.5 + 0.5;
                this.size = Math.random() * 0.5 + 0.5;
                this.yBase = this.y;
                this.offset = Math.random() * 100;
            }
            update() {
                this.x += this.speed;
                this.y = this.yBase + Math.sin(time * 0.02 + this.offset) * 10;
                if (this.x > width + 50) {
                    this.x = -50;
                    this.yBase = Math.random() * (height * 0.5);
                }
            }
            draw(opacity) {
                if (opacity <= 0.01) return;
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.lineWidth = 2 * this.size;
                ctx.lineCap = 'round';
                let s = 10 * this.size;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.quadraticCurveTo(this.x - s, this.y - s, this.x - s*2, this.y + s*0.5);
                ctx.moveTo(this.x, this.y);
                ctx.quadraticCurveTo(this.x + s, this.y - s, this.x + s*2, this.y + s*0.5);
                ctx.stroke();
            }
        }

        function initEntities() {
            stars = []; clouds = []; seagulls = [];
            for(let i=0; i<150; i++) stars.push(new Star());
            for(let i=0; i<15; i++) clouds.push(new Cloud());
            for(let i=0; i<8; i++) seagulls.push(new Seagull());
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initEntities();
        }
        window.addEventListener('resize', resize);

        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpArray(c1, c2, t) {
            return [
                Math.round(lerp(c1[0], c2[0], t)),
                Math.round(lerp(c1[1], c2[1], t)),
                Math.round(lerp(c1[2], c2[2], t))
            ];
        }
        function rgb(arr) { return `rgb(${arr[0]}, ${arr[1]}, ${arr[2]})`; }

        function getColorState() {
            // 这里的数学逻辑保持你原来的代码不变
            let ang = ((cycleAngle % 360) + 360) % 360; 
            
            if(ang > 315 || ang < 45) timeText.innerText = "NOON";
            else if(ang >= 45 && ang < 135) timeText.innerText = "SUNSET";
            else if(ang >= 135 && ang < 225) timeText.innerText = "MIDNIGHT";
            else timeText.innerText = "DAWN";

            if (ang >= 0 && ang < 90) return blendState(palette.noon, palette.sunset, ang/90);
            else if (ang >= 90 && ang < 180) return blendState(palette.sunset, palette.night, (ang-90)/90);
            else if (ang >= 180 && ang < 270) return palette.night;
            else {
                let t = (ang - 270) / 90;
                if(t < 0.2) return blendState(palette.night, palette.sunset, t*5); 
                else return blendState(palette.sunset, palette.noon, (t-0.2)*1.25);
            }
        }
        function blendState(s1, s2, t) {
            return {
                sky: lerpArray(s1.sky, s2.sky, t),
                sea: lerpArray(s1.sea, s2.sea, t),
                sun: lerpArray(s1.sun, s2.sun, t)
            };
        }

        function drawScene() {
            if (rotationDirection !== 0) cycleAngle += rotationDirection * rotationSpeed;
            
            let ang = ((cycleAngle % 360) + 360) % 360;
            const colors = getColorState();
            const horizon = height * 0.6;

            let dayIntensity = 0;
            if (ang < 90 || ang > 270) {
                if(ang < 90) dayIntensity = 1 - (ang/90);
                else dayIntensity = (ang-270)/90;
            }
            
            let grad = ctx.createLinearGradient(0, 0, 0, horizon);
            grad.addColorStop(0, rgb(colors.sky));
            grad.addColorStop(1, `rgba(${colors.sky[0]*0.9}, ${colors.sky[1]*0.9}, ${colors.sky[2]*0.9}, 1)`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, horizon);

            time++;

            let nightIntensity = 1 - dayIntensity;
            if (nightIntensity > 0) {
                stars.forEach(s => s.draw(nightIntensity));
            }

            if (dayIntensity > 0) {
                clouds.forEach(c => { c.update(); c.draw(dayIntensity); });
                seagulls.forEach(s => { s.update(); s.draw(dayIntensity); });
            }

            // 轨道计算 (你原来的逻辑)
            let rad = (cycleAngle - 90) * (Math.PI / 180);
            let orbitCy = horizon + 200; 
            let orbitRx = width * 0.4;
            let orbitRy = height * 0.8; 
            
            let sunX = width/2 + Math.cos(rad) * orbitRx;
            let sunY = orbitCy + Math.sin(rad) * orbitRy;
            
            let moonX = width/2 + Math.cos(rad + Math.PI) * orbitRx;
            let moonY = orbitCy + Math.sin(rad + Math.PI) * orbitRy;

            let lightSource = null;

            if (moonY < horizon + 60) {
                drawCelestialBody(moonX, moonY, true, colors.sun); 
                if (moonY < horizon + 50) lightSource = {x: moonX, y: moonY, color: colors.sun};
            }
            if (sunY < horizon + 60) {
                drawCelestialBody(sunX, sunY, false, colors.sun);
                if (sunY < horizon + 50) lightSource = {x: sunX, y: sunY, color: colors.sun};
            }

            drawOcean(colors, lightSource, horizon);

            requestAnimationFrame(drawScene);
        }

        function drawCelestialBody(x, y, isMoon, color) {
            const size = isMoon ? 45 : 60;
            const horizon = height * 0.6;
            if (y - size > horizon) return;

            for(let i=0; i<5; i++) {
                let r = size + i*10 + Math.sin(time*0.1)*2;
                let alpha = (1 - i/5) * 0.3;
                let distToHorizon = horizon - y;
                if (distToHorizon < 100) alpha *= Math.max(0, distToHorizon/100);

                ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI*2);
                ctx.stroke();
            }

            ctx.fillStyle = rgb(color);
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI*2);
            ctx.fill();
            
            if (isMoon) {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath(); ctx.arc(x-10, y-5, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x+5, y+10, 5, 0, Math.PI*2); ctx.fill();
            }
        }

        function drawOcean(colors, lightSource, horizon) {
            ctx.fillStyle = rgb(colors.sea);
            ctx.fillRect(0, horizon, width, height - horizon);

            let reflectionOpacity = 0;
            if (lightSource) {
                let distAbove = horizon - lightSource.y; 
                if (distAbove > -80) {
                     reflectionOpacity = 1;
                     if (distAbove < 50) { 
                         reflectionOpacity = (distAbove + 80) / 130;
                     }
                }
            }
            if (reflectionOpacity < 0) reflectionOpacity = 0;

            const rows = 45;
            for (let i = 0; i < rows; i++) {
                let pct = i / rows;
                let y = horizon + Math.pow(pct, 2) * (height - horizon);
                let step = 20 + pct * 30;
                
                for (let x = 0; x < width; x += step) {
                    let waveX = x + Math.sin(time*0.02 + i + x*0.01) * 10;
                    let isReflect = false;
                    let reflectAlpha = 0;
                    
                    if (lightSource && reflectionOpacity > 0.01) {
                        let dist = Math.abs(waveX - lightSource.x);
                        let reflectW = 80 + pct * 500; 
                        if (dist < reflectW / 2) {
                            isReflect = true;
                            reflectAlpha = 1 - (dist/(reflectW/2));
                            reflectAlpha *= reflectionOpacity;
                        }
                    }
                    
                    ctx.beginPath();
                    ctx.lineWidth = 3 + pct * 5;
                    
                    if (isReflect) {
                        let glimmer = 0.5 + Math.sin(time*0.1 + waveX)*0.5;
                        ctx.strokeStyle = `rgba(${lightSource.color[0]}, ${lightSource.color[1]}, ${lightSource.color[2]}, ${reflectAlpha * glimmer})`;
                    } else {
                        ctx.strokeStyle = `rgba(${colors.sea[0]*0.9}, ${colors.sea[1]*0.9}, ${colors.sea[2]*0.9}, 0.6)`;
                    }
                    
                    ctx.moveTo(waveX, y);
                    ctx.lineTo(waveX + step*0.8, y);
                    ctx.stroke();
                }
            }
        }

        resize();
        initEntities();
        drawScene();

    </script>
</body>
</html>